{"version":3,"sources":["holmes.js","on-click.js","scroll-top-offset.js","smoothscroll.js","app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["/**\n * search for dom elements on your page\n * @module holmes\n */\n(function(root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return (root.holmes = factory(document));\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory(document);\n  } else {\n    // Browser globals\n    root.holmes = factory(document);\n  }\n})(this, function(document) {\n  // UMD Definition above, do not remove this line\n\n  // To get to know more about the Universal Module Definition\n  // visit: https://github.com/umdjs/umd\n\n  'use strict';\n\n  /**\n   * search for dom elements on your page\n   * @alias module:holmes\n   * @param {string} [options.input='input[type=search]']\n   *   A <code>querySelector</code> to find the <code>input</code>\n   * @param {string} options.find\n   *   A <code>querySelectorAll</code> rule to find each of the find terms\n   * @param {string=} options.placeholder\n   *   Text to show when there are no results (<code>innerHTML</code>)\n   * @param {string} [options.class.visible=false]\n   *   class to add to matched items\n   * @param {string} [options.class.hidden='hidden']\n   *   class to add to non-matched items\n   * @param {boolean} [options.dynamic=false]\n   *   Whether to query for the content of the elements on every input.\n   *   If this is <code>false</code>, then only when initializing the script will\n   *   fetch the content of the elements to search in. If this is <code>true</code>\n   *   then it will refresh on every <code>input</code> event.\n   * @param {boolean} [options.contenteditable=false]\n   *   whether the input is a contenteditable or not. By default it's\n   *   assumed that it's <code>&lt;input&gt;</code>, <code>true</code> here\n   *   will use <code>&lt;div contenteditable&gt;</code>\n   * @param {boolean} [options.instant=false]\n   *   By default Holmes waits for the <code>DOMContentLoaded</code> event to fire\n   *   before listening. This is to make sure that all content is available. However\n   *   if you exactly know when all your content is available (ajax, your own event or\n   *   other situations), you can put this option on <code>true</code>.\n   * @param {number} [minCharacters=0] The minimum amount of characters to be typed before\n   *   Holmes starts searching. Beware that this also counts when backspacing.\n   * @param {onChange} [options.onHidden]\n   *   Callback for when an item is hidden.\n   * @param {onChange} [options.onVisible]\n   *   Callback for when an item is visible again.\n   * @param {onChange} [options.onEmpty]\n   *   Callback for when no items were found.\n   * @param {onChange} [options.onFound]\n   *   Callback for when items are found after being empty.\n   */\n  function holmes(options) {\n\n    var empty = false;\n\n    if (typeof options != 'object') {\n      throw new Error('The options need to be given inside an object like this:\\nholmes({\\n\\tfind:\".result\",\\n\\tdynamic:false\\n});\\n see also https://haroen.me/holmes/doc/module-holmes.html');\n    }\n\n    // if options.find is missing, the searching won't work so we'll thrown an exceptions\n    if (typeof options.find == 'undefined') {\n      throw new Error('A find argument is needed. That should be a querySelectorAll for each of the items you want to match individually. You should have something like: \\nholmes({\\n\\tfind:\".result\"\\n});\\nsee also https://haroen.me/holmes/doc/module-holmes.html');\n    }\n\n    // whether to start immediately or wait on the load of DOMContent\n    if (typeof options.instant == 'undefined') {\n      options.instant = false;\n    }\n\n    if (options.instant) {\n      start();\n    } else {\n      window.addEventListener('DOMContentLoaded', start);\n    }\n\n    // start listening\n    function start() {\n\n      // setting default values\n      if (typeof options.input == 'undefined') {\n        options.input = 'input[type=search]';\n      }\n      if (typeof options.placeholder == 'undefined') {\n        options.placeholder = false;\n      }\n      if (typeof options.class == 'undefined') {\n        options.class = {};\n      }\n      if (typeof options.class.visible == 'undefined') {\n        options.class.visible = false;\n      }\n      if (typeof options.class.hidden == 'undefined') {\n        options.class.hidden = 'hidden';\n      }\n      if (typeof options.dynamic == 'undefined') {\n        options.dynamic = false;\n      }\n      if (typeof options.contenteditable == 'undefined') {\n        options.contenteditable = false;\n      }\n      if (typeof options.minCharacters == 'undefined') {\n        options.minCharacters = 0;\n      }\n\n      // find the search and the elements\n      var search = document.querySelector(options.input);\n      var elements = document.querySelectorAll(options.find);\n      var elementsLength = elements.length;\n\n      /**\n       * The amount of elements that are hidden\n       * @type {Number}\n       */\n      holmes.prototype.hidden = 0;\n\n      // create a container for a placeholder\n      if (options.placeholder) {\n        var placeholder = document.createElement('div');\n        placeholder.id = \"holmes-placeholder\";\n        placeholder.classList.add(options.class.hidden);\n        placeholder.innerHTML = options.placeholder;\n        elements[0].parentNode.appendChild(placeholder);\n      }\n\n      // if a visible class is given, give it to everything\n      if (options.class.visible) {\n        var i;\n        for (i = 0; i < elementsLength; i++) {\n          elements[i].classList.add(options.class.visible);\n        }\n      }\n\n      // listen for input\n      search.addEventListener('input', function() {\n\n        // by default the value isn't found\n        var found = false;\n\n        // if a minimum of characters is required\n        // check if that limit has been reached\n        if (options.minCharacters) {\n          if (options.minCharacters > search.value.length && search.value.length !== 0) {\n            return;\n          }\n        }\n\n        // search in lowercase\n        var searchString;\n        if (options.contenteditable) {\n          searchString = search.textContent.toLowerCase();\n        } else {\n          searchString = search.value.toLowerCase();\n        }\n\n        // if the dynamic option is enabled, then we should query\n        // for the contents of `elements` on every input\n        if (options.dynamic) {\n          elements = document.querySelectorAll(options.find);\n          elementsLength = elements.length;\n        }\n\n        // loop over all the elements\n        // in case this should become dynamic, query for the elements here\n        var i;\n        for (i = 0; i < elementsLength; i++) {\n\n          // if the current element doesn't contain the search string\n          // add the hidden class and remove the visbible class\n          if (elements[i].textContent.toLowerCase().indexOf(searchString) === -1) {\n            if (options.class.visible) {\n              elements[i].classList.remove(options.class.visible);\n            }\n            if (!elements[i].classList.contains(options.class.hidden)) {\n              elements[i].classList.add(options.class.hidden);\n              holmes.prototype.hidden++;\n\n              if (typeof options.onHidden === 'function') {\n                options.onHidden(elements[i]);\n              }\n            }\n          // else\n          // remove the hidden class and add the visible\n          } else {\n            if (options.class.visible) {\n              elements[i].classList.add(options.class.visible);\n            }\n            if (elements[i].classList.contains(options.class.hidden)) {\n              elements[i].classList.remove(options.class.hidden);\n              holmes.prototype.hidden--;\n\n              if (empty && typeof options.onFound === 'function') {\n                options.onFound(placeholder);\n              }\n              if (typeof options.onVisible === 'function') {\n                options.onVisible(elements[i]);\n              }\n              empty = false;\n            }\n\n            // the element is now found at least once\n            found = true;\n          }\n        };\n\n        // No results were found and last time we checked it wasn't empty\n        if (!found && !empty) {\n          empty = true;\n\n          if (options.placeholder) {\n            placeholder.classList.remove(options.class.hidden);\n          }\n          if (typeof options.onEmpty === 'function') {\n            options.onEmpty(placeholder);\n          }\n        } else if(!empty) {\n          if (options.placeholder) {\n            placeholder.classList.add(options.class.hidden);\n          }\n        }\n      });\n    };\n\n    /**\n     * empty the search string programmatically.\n     * This avoids having to send a new `input` event\n     */\n    holmes.prototype.clear = function() {\n      var search = document.querySelector(options.input);\n      if (options.contenteditable) {\n        search.textContent = '';\n      } else {\n        search.value = '';\n      }\n      // if a visible class is given, give it to everything\n      if (options.class.visible) {\n        var i,\n          elements = document.querySelectorAll(options.find),\n          elementsLength = elements.length;\n        for (i = 0; i < elementsLength; i++) {\n          elements[i].classList.remove(options.class.hidden);\n          elements[i].classList.add(options.class.visible);\n        }\n      }\n      if (options.placeholder) {\n        var placeholder = document.getElementById('holmes-placeholder');\n        placeholder.classList.add(options.class.hidden);\n        if (options.class.visible) {\n          placeholder.classList.remove(options.class.visible);\n        }\n      }\n    };\n\n    /**\n     * Show the amount of elements, and those hidden and visible\n     * @return {object} all matching elements, the amount of hidden and the amount of visible elements\n     */\n    holmes.prototype.count = function() {\n      var find = document.querySelectorAll(options.find);\n      var all = find.length;\n      var hidden = holmes.prototype.hidden;\n      var visible = all - hidden;\n      return {\n        all,\n        hidden,\n        visible\n      };\n    }\n\n  };\n\n  /**\n   * Callback used for changes in item en list states.\n   * @callback onChange\n   * @param {object} [element]\n   *   Element affected by the event. This is the item found by\n   *   <code>onVisible</code> and <code>onHidden</code> and the placeholder\n   *   (or <code>undefined</code>) for <code>onEmpty</code> and\n   *   <code>onFound</code>.\n   */\n\n  return holmes;\n\n});\n","(function(window){\n    var elements = document.querySelectorAll('[data-click]');\n    Array.prototype.forEach.call(elements, function(el, i){\n        el.addEventListener('click', function(){\n            project[el.getAttribute('data-click')]();\n        });\n    });\n})(window);\n","/*\n * Navigation scroll state\n */\n(function(window){\nwindow.scrollTopOffset = function(offset, callbackTrue, callbackFalse, parameter){\n    window.addEventListener('scroll', function(f){\n        clearTimeout(f);\n        f = setTimeout(function(){\n            if((document && document.documentElement.scrollTop  || document.body && document.body.scrollTop  || 0 ) > offset ){\n                callbackTrue.call(window, parameter)\n            }else{\n                callbackFalse.call(window, parameter)\n            }\n        },10);\n    });\n}\n})(window);\n","(function (root, smoothScroll) {\n  'use strict';\n\n  // Support RequireJS and CommonJS/NodeJS module formats.\n  // Attach smoothScroll to the `window` when executed as a <script>.\n\n  // RequireJS\n  if (typeof define === 'function' && define.amd) {\n    define(smoothScroll);\n\n  // CommonJS\n  } else if (typeof exports === 'object' && typeof module === 'object') {\n    module.exports = smoothScroll();\n\n  } else {\n    root.smoothScroll = smoothScroll();\n  }\n\n})(this, function(){\n'use strict';\n\n// Do not initialize smoothScroll when running server side, handle it in client:\nif (typeof window !== 'object') return;\n\n// We do not want this script to be applied in browsers that do not support those\n// That means no smoothscroll on IE9 and below.\nif(document.querySelectorAll === void 0 || window.pageYOffset === void 0 || history.pushState === void 0) { return; }\n\n// Get the top position of an element in the document\nvar getTop = function(element) {\n    // return value of html.getBoundingClientRect().top ... IE : 0, other browsers : -pageYOffset\n    if(element.nodeName === 'HTML') return -window.pageYOffset\n    return element.getBoundingClientRect().top + window.pageYOffset;\n}\n// ease in out function thanks to:\n// http://blog.greweb.fr/2012/02/bezier-curve-based-easing-functions-from-concept-to-implementation/\nvar easeInOutCubic = function (t) { return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 }\n\n// calculate the scroll position we should be in\n// given the start and end point of the scroll\n// the time elapsed from the beginning of the scroll\n// and the total duration of the scroll (default 500ms)\nvar position = function(start, end, elapsed, duration) {\n    if (elapsed > duration) return end;\n    return start + (end - start) * easeInOutCubic(elapsed / duration); // <-- you can change the easing funtion there\n    // return start + (end - start) * (elapsed / duration); // <-- this would give a linear scroll\n}\n\n// we use requestAnimationFrame to be called by the browser before every repaint\n// if the first argument is an element then scroll to the top of this element\n// if the first argument is numeric then scroll to this location\n// if the callback exist, it is called when the scrolling is finished\n// if context is set then scroll that element, else scroll window \nvar smoothScroll = function(el, duration, callback, context){\n    duration = duration || 500;\n    context = context || window;\n    var start = window.pageYOffset;\n\n    if (typeof el === 'number') {\n      var end = parseInt(el);\n    } else {\n      var end = getTop(el);\n    }\n\n    var clock = Date.now();\n    var requestAnimationFrame = window.requestAnimationFrame ||\n        window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||\n        function(fn){window.setTimeout(fn, 15);};\n\n    var step = function(){\n        var elapsed = Date.now() - clock;\n        if (context !== window) {\n        \tcontext.scrollTop = position(start, end, elapsed, duration);\n        }\n        else {\n        \twindow.scroll(0, position(start, end, elapsed, duration));\n        }\n\n        if (elapsed > duration) {\n            if (typeof callback === 'function') {\n                callback(el);\n            }\n        } else {\n            requestAnimationFrame(step);\n        }\n    }\n    step();\n}\n\nvar linkHandler = function(ev) {\n    ev.preventDefault();\n\n    if (location.hash !== this.hash) window.history.pushState(null, null, this.hash)\n    // using the history api to solve issue #1 - back doesn't work\n    // most browser don't update :target when the history api is used:\n    // THIS IS A BUG FROM THE BROWSERS.\n    // change the scrolling duration in this call\n    smoothScroll(document.getElementById(this.hash.substring(1)), 500, function(el) {\n        location.replace('#' + el.id)\n        // this will cause the :target to be activated.\n    });\n}\n\n// We look for all the internal links in the documents and attach the smoothscroll function\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    var internal = document.querySelectorAll('a[href^=\"#\"]:not([href=\"#\"])'), a;\n    for(var i=internal.length; a=internal[--i];){\n        a.addEventListener(\"click\", linkHandler, false);\n    }\n});\n\n// return smoothscroll API\nreturn smoothScroll;\n\n});\n","var project = {};\n/* --------------------------\n * Document ready function\n*/\nfunction ready(fn) {\n  if (document.readyState != 'loading'){\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', fn);\n  }\n}\n/* --------------------------\n * MAIN SCRIPT\n */\nready(function(window){\n    // document is ready\n    // -------------\n    // set menu is scrolled states\n    scrollTopOffset(100, function(el){\n        el.classList.add('is-scrolled');\n    }, function(el){\n        el.classList.remove('is-scrolled');\n    }, document.querySelector('.o-header'));\n// end document ready\n}(window));\n// -------------\n// toggle mobile menu\nproject.toggle_mobile_menu = function(){\n    document.querySelector('.c-nav--pages').classList.toggle('is-active');\n}\n\nvar positionSectionMenu = function(){\n    var menu = document.querySelector('.js-section-menu');\n    if(menu !== null){\n    \tvar winWidth = parseInt(window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);\n    \tvar substract = ((winWidth - 1200)/6);\n    \tif( winWidth > 1150 && substract > 0){\n    \t\tmenu.style.right = substract + 'px';\n    \t}\n    \telse\n    \t{\n    \t\tmenu.style.right = \"\";\n    \t}\n\n        var links = menu.querySelectorAll('.js-section-menu-link a');\n        Array.prototype.forEach.call(links, function(item){\n            item.addEventListener('click', function(e){\n                e.preventDefault();\n                smoothScroll(document.querySelector(item.getAttribute('href')));\n            });\n        });\n    }\n};\npositionSectionMenu();\n\nwindow.addEventListener('resize', function(f){\n\twindow.clearTimeout(f);\n\tf = window.setTimeout(function(){\n\t\tpositionSectionMenu();\n\t},100);\n});\n\n\n// ---------------------------\n// Cards\n//\n    var references = document.querySelectorAll('.o-reference');\n    Array.prototype.forEach.call(references, function(item, i){\n        item.querySelector('.js-card-details').addEventListener('click', function(e){\n            Array.prototype.forEach.call(document.querySelectorAll('.is-turned'), function(item, i){\n                item.classList.remove('is-turned');\n            });\n            item.classList.add('is-turned');\n        });\n        item.querySelector('.js-close').addEventListener('click', function(){\n            item.classList.remove('is-turned');\n        });\n    });\n    // ---------------------------\n    // Search\n    //\n    if(document.querySelector('.js-collection-search') !== null){\n        var searchInput = document.querySelector('.js-collection-search input');\n        var countDisplay = document.querySelector('.js-searchable-itemCount');\n        var h = new holmes({\n          input: '.js-collection-search input',\n          find: '.js-collection-with-search .o-fragment',\n          minCharacters: 3,\n          placeholder: '<div class=\"stream-emptyState\">keine Ergebnisse</div>',\n        });\n\n    var updateCount = function(holmes, countDisplay){\n        setTimeout(function(){\n            count = holmes.count().visible;\n            var suffix = count == 1 ? ' Ergebnis' : ' Ergebnisse';\n            countDisplay.innerHTML =  count + suffix;\n        },100);\n    }\n    updateCount(h, countDisplay);\n\n    searchInput.addEventListener('input', function(){\n        updateCount(h, countDisplay);\n    });\n}\n"],"sourceRoot":"/source/"}